<!DOCTYPE html>
<html>
<head>
  <title>Hypersonic 2P</title>
  <style>
    body { 
      background: black; 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      justify-content: center; 
      height: 100vh; 
      margin: 0; 
      color: white; 
      font-family: sans-serif; 
      overflow: hidden; 
    }
    canvas { 
      background: black; 
      display: block; 
      border: 5px solid white; 
      box-sizing: border-box;
    }
    #startMenu, #gameOverMenu, #countdownOverlay { 
      position: absolute;
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      justify-content: center;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.8);
      color: white;
      font-family: sans-serif;
      z-index: 10;
    }
    #startMenu button, #gameOverMenu button { 
      background:black;
      color:#00ffff;
      border:3px solid #00ffff;
      font-size:1.5em;
      padding:15px 40px;
      cursor:pointer;
      text-transform:uppercase;
      letter-spacing:2px;
      box-shadow:0 0 10px #00ffff;
      transform: skew(-20deg);
      transition:all 0.3s ease;
      margin-top:20px;
    }
    #gameOverMenu { display: none; }
    #countdownOverlay { 
      display: none; 
      font-size: 6em; 
      font-weight: bold;
    }
    #jumpsInfo {
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      width: 48%;
    }
    .jump-display {
      display: flex;
      gap: 8px;
      align-items: center;
      font-weight: bold;
      font-size: 16px;
    }
    .jump-label {
      margin-right: 8px;
    }
    #p1Jumps { color: cyan; }
    #p2Jumps { color: lime; flex-direction: row-reverse; }
    #p2Jumps .jump-label { margin-right: 0; margin-left: 8px; }
  </style>
</head>
<body>
<div id="startMenu">
  <h1>Hypersonic 2P</h1>
  <button id="startButton">Start Game</button>
</div>

<div id="gameOverMenu">
  <h1 id="gameOverMessage">Game Over!</h1>
  <div style="display:flex; gap:20px; justify-content:center; margin-top:30px;">
    <button id="playAgainButton">Play Again</button>
    <button onclick="window.location.href='index.html'">Home</button>
  </div>
</div>

<div id="countdownOverlay"></div>

<div id="jumpsInfo">
  <div id="p1Jumps" class="jump-display"></div>
  <div id="p2Jumps" class="jump-display"></div>
</div>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const p1JumpsDisplay = document.getElementById("p1Jumps");
const p2JumpsDisplay = document.getElementById("p2Jumps");
const countdownOverlay = document.getElementById("countdownOverlay");

let grid = 20;
let step;
let snakeSize;
let gameRunning = false;
let lastMoveTime = 0;
const moveDelay = 50;

function resizeCanvas() {
  const size = Math.min(window.innerWidth * 0.95, window.innerHeight * 0.95);
  canvas.width = size;
  canvas.height = size;
  grid = Math.max(8, Math.floor(size / 30));
  step = grid * 0.5;
  snakeSize = grid * 0.5;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

class Snake {
  constructor(color, x, y, keys, vx=1, vy=0){
    this.color = color;
    this.x = Math.round(x / grid) * grid;
    this.y = Math.round(y / grid) * grid;
    this.vx = vx; this.vy = vy;
    this.trail = [{x:this.x,y:this.y}];
    this.alive = true;
    this.keys = keys;
    this.framesAlive = 0;
    this.jumps = 2;
    this.jumpActive = false;
  }

  move(){
    if(!this.alive) return;
    this.x = (this.x + this.vx*step + canvas.width)%canvas.width;
    this.y = (this.y + this.vy*step + canvas.height)%canvas.height;
    this.trail.push({x:this.x,y:this.y});
    this.framesAlive++;
    if(this.jumpActive){
      destroyTrailAhead(this, 4);
      this.jumpActive=false;
    }
  }

  draw(){
    ctx.fillStyle=this.color;
    this.trail.forEach(p=>ctx.fillRect(p.x,p.y,snakeSize,snakeSize));
    const head=this.trail[this.trail.length-1];
    ctx.fillStyle="black";
    ctx.fillRect(head.x, head.y, snakeSize, snakeSize);
    ctx.fillStyle="white";
    ctx.beginPath();
    ctx.arc(head.x+snakeSize/2, head.y+snakeSize/2, snakeSize/2, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle="black";
    ctx.beginPath();
    ctx.arc(head.x+snakeSize/2, head.y+snakeSize/2, snakeSize/4,0,Math.PI*2);
    ctx.fill();
  }

  checkCollision(snakes){
    if(this.framesAlive<5) return;
    snakes.forEach(snake=>{
      snake.trail.forEach((p,idx)=>{
        if(this!==snake || idx<snake.trail.length-1){
          const dx=Math.min(Math.abs(this.x-p.x),canvas.width-Math.abs(this.x-p.x));
          const dy=Math.min(Math.abs(this.y-p.y),canvas.height-Math.abs(this.y-p.y));
          if(dx<snakeSize && dy<snakeSize) this.alive=false;
        }
      });
    });
  }
}

let snake1, snake2, snakes;
let jumpItem;

function initGame(){
  const offset=grid*2;
  const endOffset=grid*3;
  snake1=new Snake("cyan", offset, offset, {up:"w",left:"a",down:"s",right:"d"});
  snake2=new Snake("lime", canvas.width-endOffset, canvas.height-endOffset, 
    {up:"ArrowUp",left:"ArrowLeft",down:"ArrowDown",right:"ArrowRight"}, -1, 0);
  snakes=[snake1,snake2];
  lastMoveTime=0;

  spawnJumpItem();
  updateJumpsDisplay();
}

document.addEventListener("keydown", e=>{
  if(!gameRunning) return;
  snakes.forEach(s=>{
    if(e.key===s.keys.up && s.vy===0){s.vx=0;s.vy=-1;}
    if(e.key===s.keys.down && s.vy===0){s.vx=0;s.vy=1;}
    if(e.key===s.keys.left && s.vx===0){s.vx=-1;s.vy=0;}
    if(e.key===s.keys.right && s.vx===0){s.vx=1;s.vy=0;}
  });
  if((e.key==="e"||e.key==="E") && snake1.jumps>0){snake1.jumpActive=true;snake1.jumps--;updateJumpsDisplay();}
  if((e.key==="/"||e.key==="?") && snake2.jumps>0){snake2.jumpActive=true;snake2.jumps--;updateJumpsDisplay();}
});

function updateJumpsDisplay(){
  function renderJumps(container, jumpsLeft, color, isLime=false){
    container.innerHTML = "";
    const text = document.createElement("span");
    text.classList.add("jump-label");
    text.textContent = "Jumps";

    container.style.display = "flex";
    container.style.alignItems = "center";

    if(isLime){
      container.style.flexDirection = "row-reverse";
      text.style.marginLeft = "0.5em";
      text.style.marginRight = "0";
    } else {
      container.style.flexDirection = "row";
      text.style.marginRight = "0.5em";
      text.style.marginLeft = "0";
    }

    container.appendChild(text);

    for(let i=0; i<jumpsLeft; i++){
      const circle = document.createElement("div");
      circle.style.position = "relative";
      circle.style.width = "1.2em";
      circle.style.aspectRatio = "1 / 1";

      const outerRing = document.createElement("div");
      outerRing.style.width = "100%";
      outerRing.style.height = "100%";
      outerRing.style.borderRadius = "50%";
      outerRing.style.border = `0.18em solid ${color}`;
      outerRing.style.position = "absolute";
      outerRing.style.inset = "0";

      const innerFill = document.createElement("div");
      innerFill.style.width = "82%";
      innerFill.style.height = "82%";
      innerFill.style.borderRadius = "50%";
      innerFill.style.background = color;
      innerFill.style.position = "absolute";
      innerFill.style.top = "50%";
      innerFill.style.left = "50%";
      innerFill.style.transform = "translate(-35%, -35%)";

      const highlight = document.createElement("div");
      highlight.style.width = "40%";
      highlight.style.height = "40%";
      highlight.style.borderRadius = "50%";
      highlight.style.background = "white";
      highlight.style.position = "absolute";
      highlight.style.top = "15%";
      highlight.style.left = "12%";

      innerFill.appendChild(highlight);
      circle.appendChild(outerRing);
      circle.appendChild(innerFill);
      container.appendChild(circle);
    }
  }
  renderJumps(p1JumpsDisplay, snake1.jumps, "cyan");
  renderJumps(p2JumpsDisplay, snake2.jumps, "lime", true);
}

function destroyTrailAhead(snake,lengthCells){
  const head=snake.trail[snake.trail.length-1];
  for(let i=1;i<=lengthCells;i++){
    const tx=(head.x+snake.vx*step*i+canvas.width)%canvas.width;
    const ty=(head.y+snake.vy*step*i+canvas.height)%canvas.height;
    for(let s of snakes){
      s.trail=s.trail.filter((p,idx)=>{
        if(idx>=s.trail.length-3) return true;
        const dx=Math.min(Math.abs(tx-p.x),canvas.width-Math.abs(tx-p.x));
        const dy=Math.min(Math.abs(ty-p.y),canvas.height-Math.abs(ty-p.y));
        return !(dx<snakeSize && dy<snakeSize);
      });
    }
  }
}

function spawnJumpItem(){
  const size = grid;
  let safe = false;
  let x, y;

  while(!safe){
    x = Math.floor(Math.random()*(canvas.width-size)/grid)*grid;
    y = Math.floor(Math.random()*(canvas.height-size)/grid)*grid;
    safe = true;

    for(const snake of snakes){
      for(const point of snake.trail){
        const dx = Math.abs(x - point.x);
        const dy = Math.abs(y - point.y);
        if(dx <= grid*3 && dy <= grid*3){
          safe = false;
          break;
        }
      }
      if(!safe) break;
    }
  }

  jumpItem = { x, y };
}

function drawJumpItem(){
  if(!jumpItem) return;
  const size = grid*0.6;
  const cx = jumpItem.x + grid/2;
  const cy = jumpItem.y + grid/2;
  ctx.strokeStyle="orange";
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.arc(cx,cy,size/2,0,Math.PI*2);
  ctx.stroke();
  ctx.fillStyle="orange";
  ctx.beginPath();
  ctx.arc(cx,cy,size/3,0,Math.PI*2);
  ctx.fill();
  ctx.fillStyle="white";
  ctx.beginPath();
  ctx.arc(cx - size/8, cy - size/8, size/8, 0, Math.PI*2);
  ctx.fill();
}

function checkJumpPickup(){
  [snake1,snake2].forEach(snake=>{
    if(!jumpItem) return;
    const dx=Math.abs(snake.x - jumpItem.x);
    const dy=Math.abs(snake.y - jumpItem.y);
    if(dx<grid && dy<grid){
      snake.jumps++;
      jumpItem=null;
      spawnJumpItem();
      updateJumpsDisplay();
    }
  });
}

function gameLoop(timestamp){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(!lastMoveTime) lastMoveTime=timestamp;
  if(timestamp-lastMoveTime>moveDelay){
    snakes.forEach(s=>s.move());
    snakes.forEach(s=>s.checkCollision(snakes));
    lastMoveTime=timestamp;
  }
  snakes.forEach(s=>s.draw());
  drawJumpItem();
  checkJumpPickup();
  updateJumpsDisplay();
  if(snakes.some(s=>!s.alive)){
    gameRunning=false;
    showGameOver();
    return;
  }
  requestAnimationFrame(gameLoop);
}

function showGameOver(){
  let message="";
  if(!snake1.alive&&!snake2.alive) message="It's a tie!";
  else if(!snake1.alive) message="Lime wins!";
  else if(!snake2.alive) message="Cyan wins!";
  document.getElementById("gameOverMessage").textContent=message;
  document.getElementById("gameOverMenu").style.display="flex";
}

// Countdown logic
function startCountdown(callback){
  let count = 3;
  countdownOverlay.style.display="flex";
  countdownOverlay.textContent = count;
  let interval = setInterval(()=>{
    count--;
    if(count>0){
      countdownOverlay.textContent = count;
    } else {
      clearInterval(interval);
      countdownOverlay.style.display="none";
      callback();
    }
  },600);
}

document.getElementById("startButton").addEventListener("click",()=>{
  initGame();
  document.getElementById("startMenu").style.display="none";
  document.getElementById("gameOverMenu").style.display="none";
  canvas.style.display="block";
  startCountdown(()=>{
    gameRunning=true;
    requestAnimationFrame(gameLoop);
  });
});

document.getElementById("playAgainButton").addEventListener("click",()=>{
  initGame();
  document.getElementById("gameOverMenu").style.display="none";
  startCountdown(()=>{
    gameRunning=true;
    requestAnimationFrame(gameLoop);
  });
});
</script>
</body>
</html>
