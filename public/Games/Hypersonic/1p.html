<!DOCTYPE html>
<html>
<head>
  <title>Hypersonic 1P</title>
  <style>
    body { background: black; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; color: white; font-family: sans-serif; overflow: hidden; }
    canvas { background: black; display: block; border: 5px solid white; box-sizing: border-box; }
    #startMenu, #gameOverMenu, #countdownOverlay { position: absolute; display: flex; flex-direction: column; align-items: center; justify-content: center; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); color: white; font-family: sans-serif; z-index: 10; }
    #startMenu button, #gameOverMenu button { background:black; color:#00ffff; border:3px solid #00ffff; font-size:1.5em; padding:15px 40px; cursor:pointer; text-transform:uppercase; letter-spacing:2px; box-shadow:0 0 10px #00ffff; transform: skew(-20deg); transition:all 0.3s ease; margin-top:20px; }
    #gameOverMenu { display: none; }
    #countdownOverlay { font-size: 5em; font-weight: bold; display: none; background: rgba(0,0,0,0.6); }
    #jumpsInfo { margin-bottom: 10px; display: flex; justify-content: space-between; width: 48%; }
    .jump-display { display: flex; gap: 8px; align-items: center; font-weight: bold; font-size: 16px; }
    .jump-label { margin-right: 8px; }
  </style>
</head>
<body>
<div id="startMenu">
  <h1>Hypersonic 1P</h1>
  <button id="startButton">Start Game</button>
</div>

<div id="gameOverMenu">
  <h1 id="gameOverMessage">Game Over!</h1>
  <div style="display:flex; gap:20px; justify-content:center; margin-top:30px;">
    <button id="playAgainButton">Play Again</button>
    <button onclick="window.location.href='index.html'">Home</button>
  </div>
</div>

<div id="countdownOverlay"><span id="countdownText">3</span></div>

<div id="jumpsInfo">
  <div id="p1Jumps" class="jump-display"></div>
  <div id="p2Jumps" class="jump-display"></div>
</div>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let grid = 20, step, snakeSize, gameRunning=false, lastMoveTime=0, moveDelay=50, jumpItem;
let player, enemy, snakes;

function resizeCanvas(){
  const size = Math.min(window.innerWidth*0.95, window.innerHeight*0.95);
  canvas.width=size; canvas.height=size;
  grid = Math.max(8, Math.floor(size/30));
  step = grid*0.5;
  snakeSize = grid*0.5;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

class Snake{
  constructor(color,x,y,keys,vx=1,vy=0,isEnemy=false){
    this.color=color; this.x=Math.round(x/grid)*grid; this.y=Math.round(y/grid)*grid;
    this.vx=vx; this.vy=vy; this.trail=[{x:this.x,y:this.y}]; this.alive=true;
    this.keys=keys; this.framesAlive=0; this.isEnemy=isEnemy; this.jumps=2;
  }
  move(snakes,player){
    if(!this.alive) return;
    if(this.isEnemy){
      const allDirs=[{vx:1,vy:0},{vx:-1,vy:0},{vx:0,vy:1},{vx:0,vy:-1}];
      const safeDirs=allDirs.filter(d=>!this.willCollide(d,snakes));
      if(safeDirs.length===0 && this.jumps>0 && this.willCollide({vx:this.vx,vy:this.vy},snakes)){
        useJump(this);
      } else this.enemyAI(snakes,player);
    }
    this.x = (this.x + this.vx*step + canvas.width) % canvas.width;
    this.y = (this.y + this.vy*step + canvas.height) % canvas.height;
    this.trail.push({x:this.x,y:this.y});
    this.framesAlive++;
  }
  draw(){
    ctx.fillStyle=this.color;
    this.trail.forEach(p=>ctx.fillRect(p.x,p.y,snakeSize,snakeSize));
    const head=this.trail[this.trail.length-1];
    ctx.fillStyle="black"; ctx.fillRect(head.x,head.y,snakeSize,snakeSize);
    ctx.fillStyle="white"; ctx.beginPath();
    ctx.arc(head.x+snakeSize/2,head.y+snakeSize/2,snakeSize/2,0,Math.PI*2); ctx.fill();
    ctx.fillStyle="black"; ctx.beginPath();
    ctx.arc(head.x+snakeSize/2,head.y+snakeSize/2,snakeSize/4,0,Math.PI*2); ctx.fill();
  }
  checkCollision(snakes){
    if(this.framesAlive<5) return;
    snakes.forEach(snake=>{
      snake.trail.forEach((p,idx)=>{
        if(this!==snake || idx<snake.trail.length-1){
          const dx=Math.min(Math.abs(this.x-p.x), canvas.width-Math.abs(this.x-p.x));
          const dy=Math.min(Math.abs(this.y-p.y), canvas.height-Math.abs(this.y-p.y));
          if(dx<snakeSize && dy<snakeSize) this.alive=false;
        }
      });
    });
  }
  willCollide(dir,snakes){
    const nx=(this.trail[this.trail.length-1].x + dir.vx*step + canvas.width) % canvas.width;
    const ny=(this.trail[this.trail.length-1].y + dir.vy*step + canvas.height) % canvas.height;
    for(let snake of snakes){
      for(let i=0;i<snake.trail.length;i++){
        const p=snake.trail[i];
        const dx=Math.min(Math.abs(nx-p.x), canvas.width-Math.abs(nx-p.x));
        const dy=Math.min(Math.abs(ny-p.y), canvas.height-Math.abs(ny-p.y));
        if(dx<snakeSize && dy<snakeSize) return true;
      }
    }
    return false;
  }
  enemyAI(snakes, player){
    const head = this.trail[this.trail.length-1];
    let targetX = player.x, targetY = player.y;
    if(jumpItem){
      const distToPlayer = Math.hypot(head.x - player.x, head.y - player.y);
      const distToJump = Math.hypot(head.x - jumpItem.x, head.y - jumpItem.y);
      if(distToJump + 10 < distToPlayer){
        targetX = jumpItem.x;
        targetY = jumpItem.y;
      }
    }
    const dirs=[{vx:this.vx,vy:this.vy},{vx:this.vy,vy:-this.vx},{vx:-this.vy,vy:this.vx}];
    dirs.sort((a,b)=>{
      const ax=(head.x+a.vx*step+canvas.width)%canvas.width;
      const ay=(head.y+a.vy*step+canvas.height)%canvas.height;
      const bx=(head.x+b.vx*step+canvas.width)%canvas.width;
      const by=(head.y+b.vy*step+canvas.height)%canvas.height;
      return Math.hypot(ax-targetX,ay-targetY)-Math.hypot(bx-targetX,by-targetY);
    });
    for(let dir of dirs) if(!this.willCollide(dir,snakes)){ this.vx=dir.vx; this.vy=dir.vy; return; }
    const allDirs=[{vx:1,vy:0},{vx:-1,vy:0},{vx:0,vy:1},{vx:0,vy:-1}];
    const safeDirs=allDirs.filter(d=>!this.willCollide(d,snakes));
    if(safeDirs.length>0){ const choice=safeDirs[Math.floor(Math.random()*safeDirs.length)]; this.vx=choice.vx; this.vy=choice.vy; }
  }
}

function useJump(snake) {
  if (snake.jumps <= 0) return;
  snake.jumps--;
  const head = snake.trail[snake.trail.length - 1];
  for (let i = 1; i <= 4; i++) {
    const tx = (head.x + snake.vx * step * i + canvas.width) % canvas.width;
    const ty = (head.y + snake.vy * step * i + canvas.height) % canvas.height;
    snakes.forEach(s => {
      s.trail = s.trail.filter((p, idx) => {
        const dx = Math.min(Math.abs(tx - p.x), canvas.width - Math.abs(tx - p.x));
        const dy = Math.min(Math.abs(ty - p.y), canvas.height - Math.abs(ty - p.y));
        return !(dx < snakeSize && dy < snakeSize);
      });
    });
  }
  updateJumpsDisplay();
}

function spawnJumpItem(){
  let valid=true;
  do{
    valid=true;
    jumpItem={x: Math.floor(Math.random()*(canvas.width-grid)/grid)*grid, y: Math.floor(Math.random()*(canvas.height-grid)/grid)*grid};
    snakes.forEach(s=>{ s.trail.forEach(p=>{ const dx=Math.abs(jumpItem.x-p.x); const dy=Math.abs(jumpItem.y-p.y); if(dx<=3*grid && dy<=3*grid) valid=false; }); });
  }while(!valid);
}
function drawJumpItem(){
  if(!jumpItem) return;
  const size=grid*0.6, cx=jumpItem.x+grid/2, cy=jumpItem.y+grid/2;
  ctx.strokeStyle="orange"; ctx.lineWidth=2;
  ctx.beginPath(); ctx.arc(cx,cy,size/2,0,Math.PI*2); ctx.stroke();
  ctx.fillStyle="orange"; ctx.beginPath(); ctx.arc(cx,cy,size/3,0,Math.PI*2); ctx.fill();
  ctx.fillStyle="white"; ctx.beginPath(); ctx.arc(cx-size/8,cy-size/8,size/8,0,Math.PI*2); ctx.fill();
}
function checkJumpPickup(){
  if(!jumpItem) return;
  [player,enemy].forEach(snake=>{
    const dx=Math.abs(snake.x-jumpItem.x), dy=Math.abs(snake.y-jumpItem.y);
    if(dx<grid && dy<grid){ snake.jumps++; jumpItem=null; spawnJumpItem(); updateJumpsDisplay(); }
  });
}

function updateJumpsDisplay(){
  function renderJumps(container, jumpsLeft, color, isEnemy=false){
    container.innerHTML=""; 
    const text=document.createElement("span"); 
    text.classList.add("jump-label"); 
    text.textContent="Jumps";
    container.style.display = "flex"; container.style.alignItems = "center";
    if(isEnemy){ container.style.flexDirection = "row-reverse"; text.style.marginLeft = "0.5em"; text.style.marginRight = "0"; }
    else { container.style.flexDirection = "row"; text.style.marginRight = "0.5em"; text.style.marginLeft = "0"; }
    container.appendChild(text);
    for(let i=0;i<jumpsLeft;i++){
      const circle=document.createElement("div"); circle.style.position="relative"; circle.style.width="1.2em"; circle.style.aspectRatio="1 / 1";
      const outer=document.createElement("div"); outer.style.width="100%"; outer.style.height="100%"; outer.style.borderRadius="50%"; outer.style.border=`0.18em solid ${color}`; outer.style.position="absolute"; outer.style.inset="0";
      const inner=document.createElement("div"); inner.style.width="82%"; inner.style.height="82%"; inner.style.borderRadius="50%"; inner.style.background=color; inner.style.position="absolute"; inner.style.top="50%"; inner.style.left="50%"; inner.style.transform="translate(-35%,-35%)";
      const highlight=document.createElement("div"); highlight.style.width="40%"; highlight.style.height="40%"; highlight.style.borderRadius="50%"; highlight.style.background="white"; highlight.style.position="absolute"; highlight.style.top="15%"; highlight.style.left="12%";
      inner.appendChild(highlight); circle.appendChild(outer); circle.appendChild(inner); container.appendChild(circle);
    }
  }
  renderJumps(document.getElementById("p1Jumps"), player.jumps, "cyan", false);
  renderJumps(document.getElementById("p2Jumps"), enemy.jumps, "lime", true);
}

function initGame(){
  resizeCanvas(); const offset=grid*2;
  player=new Snake("cyan",offset,offset,{up:"w",left:"a",down:"s",right:"d"},1,0,false);
  enemy=new Snake("lime",canvas.width-offset,canvas.height-offset,null,-1,0,true);
  snakes=[player,enemy]; lastMoveTime=0; spawnJumpItem(); updateJumpsDisplay();
}

document.addEventListener("keydown",e=>{
  if(!gameRunning) return;
  if(e.key===player.keys.up && player.vy===0){player.vx=0;player.vy=-1;}
  if(e.key===player.keys.down && player.vy===0){player.vx=0;player.vy=1;}
  if(e.key===player.keys.left && player.vx===0){player.vx=-1;player.vy=0;}
  if(e.key===player.keys.right && player.vx===0){player.vx=1;player.vy=0;}
  if(e.key.toLowerCase()==="e") useJump(player);
});

function gameLoop(timestamp){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(!lastMoveTime) lastMoveTime=timestamp;
  if(timestamp-lastMoveTime>moveDelay){
    snakes.forEach(s=>s.move(snakes,player));
    snakes.forEach(s=>s.checkCollision(snakes));
    lastMoveTime=timestamp;
  }
  snakes.forEach(s=>s.draw()); drawJumpItem(); checkJumpPickup(); updateJumpsDisplay();
  if(snakes.some(s=>!s.alive)){ gameRunning=false; showGameOver(); return; }
  requestAnimationFrame(gameLoop);
}

function showGameOver(){
  let message=""; if(!player.alive && !enemy.alive) message="It's a tie!"; else if(!player.alive) message="Enemy wins!"; else message="Player wins!";
  document.getElementById("gameOverMessage").textContent=message; document.getElementById("gameOverMenu").style.display="flex";
}

function startCountdown(startCallback){
  const overlay=document.getElementById("countdownOverlay");
  const text=document.getElementById("countdownText");
  let count=3;
  overlay.style.display="flex";
  text.textContent=count;
  const interval=setInterval(()=>{
    count--;
    if(count>0){ text.textContent=count; }
    else if(count===0){ text.textContent="GO!"; }
    else {
      clearInterval(interval);
      overlay.style.display="none";
      startCallback();
    }
  },600);
}

document.getElementById("startButton").addEventListener("click",()=>{
  initGame();
  document.getElementById("startMenu").style.display="none";
  document.getElementById("gameOverMenu").style.display="none";
  canvas.style.display="block";
  startCountdown(()=>{ gameRunning=true; requestAnimationFrame(gameLoop); });
});

document.getElementById("playAgainButton").addEventListener("click",()=>{
  initGame();
  document.getElementById("gameOverMenu").style.display="none";
  startCountdown(()=>{ gameRunning=true; requestAnimationFrame(gameLoop); });
});
</script>
</body>
</html>
